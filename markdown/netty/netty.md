### 从线程模型的角度看 Netty 为什么是高性能的

参考：https://www.tuicool.com/articles/YzqQJ3M

* 传统IO
	* 大概是这样，其实主要想表达的是： 这样一个线程只能处理一个连接 。如果是 100 个客户端连接那就得开 100 个线程，1000 那就得 1000 个线程。要知道线程资源非常宝贵，每次的创建都会带来消耗，而且每个线程还得为它分配对应的栈内存。即便是我们给 JVM 足够的内存，大量线程所带来的上下文切换也是受不了的。
并且传统 IO 是阻塞模式，每一次的响应必须的是发起 IO 请求，处理请求完成再同时返回，直接的结果就是性能差，吞吐量低

* Reactor 模型
	*  它是一种异步、非阻塞的事件驱动模型。
	*  1、单线程：它是由一个线程来接收客户端的连接，并将该请求分发到对应的事件处理 handler 中，整个过程完全是异步非阻塞的；并且完全不存在共享资源的问题。所以理论上来说吞吐量也还不错。
但由于是一个线程，对多核 CPU 利用率不高，一旦有大量的客户端连接上来性能必然下降，甚至会有大量请求无法响应。
最坏的情况是一旦这个线程哪里没有处理好进入了死循环那整个服务都将不可用！	
	* 2、主从多线程： 该模型将客户端连接那一块的线程也改为多线程，称为主线程。同时也是多个子线程来处理事件响应，这样无论是连接还是事件都是高性能的。

* 总结
* 其实看过了 Netty 的线程模型之后能否对我们平时做高性能应用带来点启发呢？
	* 1、接口同步转异步处理。
	* 2、回调通知结果。
	* 3、多线程提高并发效率。
* 无非也就是这些，只是做了这些之后就会带来其他问题：
	* 1、异步之后事务如何保证？
	* 2、回调失败的情况？
	* 3、多线程所带来的上下文切换、共享资源的问题。


