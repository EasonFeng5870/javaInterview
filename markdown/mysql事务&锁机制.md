#### mysql事务 锁机制
* 事务
	* 原子性：要不全部成功，要不全部撤销
	* 隔离性：事务之间相互独立，互不干扰
	* 一致性：数据库正确地改变状态后，数据库的一致性约束没有被破坏
	* 持久性：事务的提交结果，将持久保存在数据库中
* 事务的并发问题
	* 脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据
	* 不可重复读：不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。
	* 幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。
	* 小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表
* MySQL事务隔离级别

| 事务隔离级别   |      脏读      |  不可重复读 |幻读|
|----------|:-------------:|------:|------:|
| 读未提交（read-uncommitted） | yes | yes |yes |
| 读提交（read-committed） | no | yes |yes |
| 可重复读（repeatable-read）(默认) | no | no |yes |
| 串行化（serializable） | no | no |no |	 

* 行级锁
	* 1、多个事务操作同一行数据时，后来的事务处于阻塞等待状态。这样可以避免了脏读等数据一致性的问题。后来的事务可以操作其他行数据，解决了表锁高并发性能低的问题
	* 2、当执行批量修改数据脚本的时候，行锁升级为表锁。因为InnoDB只有在通过索引条件检索数据时使用行级锁，否则使用表锁！而模拟操作正是通过id去作为检索条件，而id又是MySQL自动创建的唯一索引，所以才忽略了行锁变表锁的情况
	* 3、总结：InnoDB的行锁是针对索引加的锁，不是针对记录加的锁
	* 行锁的劣势：开销大；加锁慢；会出现死锁
	* 行锁的优势：锁的粒度小，发生锁冲突的概率低；处理并发的能力强
	* 加锁的方式：自动加锁。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁；对于普通SELECT语句，InnoDB不会加任何锁；当然我们也可以显示的加锁：
	* 共享锁：select * from tableName where ... + lock in share more
	* 排他锁：select * from tableName where ... + for update
	* InnoDB和MyISAM的最大不同点有两个：一，InnoDB支持事务(transaction)二，默认采用行级锁。加锁可以保证事务的一致性，可谓是有人(锁)的地方，就有江湖(事务)；我们先简单了解一下事务知识
	* 4、间隙锁：当我们用范围条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做"间隙(GAP)"。InnoDB也会对这个"间隙"加锁，这种锁机制就是所谓的间隙锁(Next-Key锁)
	* 5、行锁优化
		*  尽可能让所有数据检索都通过索引来完成，避免无索引行或索引失效导致行锁升级为表锁。
		*  尽可能避免间隙锁带来的性能下降，减少或使用合理的检索范围
		*  尽可能减少事务的粒度，比如控制事务大小，而从减少锁定资源量和时间长度，从而减少锁的竞争等，提供性能 
	* 6、表锁
		* 表锁的优势：开销小；加锁快；无死锁
		* 表锁的劣势：锁粒度大，发生锁冲突的概率高，并发处理能力低
	* 总结：
	* InnoDB 支持表锁和行锁，使用索引作为检索条件修改数据时采用行锁，否则采用表锁。
	* InnoDB 自动给修改操作加锁，给查询操作不自动加锁
	* 行锁可能因为未使用索引而升级为表锁，所以除了检查索引是否创建的同时，也需要通过explain执行计划查询索引是否被实际使用。
	* 行锁相对于表锁来说，优势在于高并发场景下表现更突出，毕竟锁的粒度小。
	* 当表的大部分数据需要被修改，或者是多表复杂关联查询时，建议使用表锁优于行锁。
	* 为了保证数据的一致完整性，任何一个数据库都存在锁定机制。锁定机制的优劣直接影响到一个数据库的并发处理能力和性能。

* 参考地址:https://www.cnblogs.com/itdragon/p/8194622.html

 
	
	
	
	
	
	
	
	
	
	
	
	